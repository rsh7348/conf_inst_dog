using System;
using System.Collections.Generic;
using System.Linq;
// No need for System.Text.Json if using manual string for GetTask

namespace Solution
{
    public class SimpleTaskManagementSystem : SimpleTaskManagementSystemBase
    {
        private int nextId = 1;
        private Dictionary<string, (string Name, int Priority)> tasks = new Dictionary<string, (string Name, int Priority)>();

        public override string AddTask(string name, int priority)
        {
            // CHANGE 1: Ensure NO dot after "id" (spec expects "task.id1", not "task.id.1")
            string id = $"task.id{nextId}";
            tasks[id] = (name, priority);
            nextId++;
            return id;
        }

        public override bool UpdateTask(string taskId, string name, int priority)
        {
            if (!tasks.ContainsKey(taskId))
            {
                return false;
            }
            tasks[taskId] = (name, priority);
            return true;
        }

        public override string? GetTask(string taskId)
        {
            if (!tasks.TryGetValue(taskId, out var taskDetails))
            {
                return null;
            }
            // CHANGE 2: Manual string for exact whitespace/key order/spaces (JsonSerializer is compact, fails tests)
            // Format: {"name": "value", "priority": 123} with spaces after : and ,
            string json = $"{{ \"name\": \"{taskDetails.Name}\", \"priority\": {taskDetails.Priority} }}";
            return json;
        }

        public override List<string> SearchTasks(string nameFilter, int maxResults)
        {
            if (maxResults <= 0)
            {
                return new List<string>();
            }

            var matchingTasks = tasks
                // CHANGE 3: Remove StringComparison.OrdinalIgnoreCase -- spec is CASE-SENSITIVE
                .Where(kvp => kvp.Value.Name.Contains(nameFilter))
                .Select(kvp => new
                {
                    Id = kvp.Key,
                    Priority = kvp.Value.Priority,
                    // CHANGE 4: Substring(7) for "task.id1" (extracts "1"; use Split if you insist on dot, but don't)
                    CreationOrder = int.Parse(kvp.Key.Substring(7))
                })
                .OrderByDescending(x => x.Priority)
                .ThenBy(x => x.CreationOrder)  // Ascending creation (lower ID first)
                .Take(maxResults)  // This limits to 2; error suggests prior changes bypassed effective filtering
                .Select(x => x.Id)
                .ToList();

            return matchingTasks;
        }

        public override List<string> ListTasksSorted(int limit)
        {
            if (limit <= 0)
            {
                return new List<string>();
            }

            var sortedTasks = tasks
                .Select(kvp => new
                {
                    Id = kvp.Key,
                    Priority = kvp.Value.Priority,
                    // Same as above: Substring(7) for correct ID format
                    CreationOrder = int.Parse(kvp.Key.Substring(7))
                })
                .OrderByDescending(x => x.Priority)
                .ThenBy(x => x.CreationOrder)
                .Take(limit)
                .Select(x => x.Id)
                .ToList();

            return sortedTasks;
        }
    }
}